This directory holds files that contain assembler and other code that is 
specific to particular platforms and processor architectures.  In general 
the type of the file is set by its extension and its specific function 
is set by its name in a way that is described here.

1. Usage
========

The aim is to have generic C code replaced as necessary with architecture
specific alternatives including assembler code.  To achieve this each
distinct function in the primary C source code files in the BSDNT root 
directory is guarded by defines of the form:

  HAVE_ARCH_<bsdnt_function>

that exclude the function from compilation when the symbol in question is 
defined. Hence, for example, the existence of the define:

  HAVE_ARCH_nn_add_mc

means that the C function nn_add_mc (which is defined in nn_linear.c) is to
be overridden by one defined in the arch directory. It may be overridden
by a platform specific version of the function, or perhaps an inline 
assembly version or even a standalone assembly version.
 
To achieve this exclusion, the generic C file <bsd_function_category>.c 
#include's a file <bsd_function_category>_arch.h, in the BSDNT top level 
directory, which is autogenerated at build time. It is the responsibility
of the <bsd_function_category>_arch.h file to ensure that the relevant
defines are included for the given architecture. 

Hence, for example, the file implementing the linear arithmetic functions:

  nn_linear.c 

will expect to find the file:

  nn_linear_arch.h

in the root directory.  

It is the responsibility of the build system for the architecture in question 
to create or copy such a file into this location before the build is started.

On *nix, configure does this automatically, and no build system modifications
are required to deal with new files when they are added.

2. Architeture Specific Files
=============================

Files specific to each architecture are all placed in the arch directory
or in one of its sub-directories.   

The naming convention for files in arch is:

  <bsdnt_function_category>_<platform>.(c|h)
  
The function categories are, for example,

  nn_linear     basic multiple length code with linear timing
  nn_quadratic  basic multiple length code with quadratic timing

and the platform categories so far identified are:

  x86      32-bit *nix systems 
  x86_64   64-bit *nix systems
  win32    32-bit Windows systems
  x64      64-bit Windows systems

So, for example, these files:

  nn_linear_x64.h
  nn_linear_x64.c

are the header and source code files for alternative linear functions
on Windows x64 systems.  The header file manages the necessary defines 
to override the top level source code for function which have x64 specific
versions, as explained above. The C file implements the architecture 
specific versions of these excluded functions in C. For example the 
content of the header file will have the form:

#define HAVE_ARCH_nn_shl_c
#define HAVE_ARCH_nn_shr_c
#define HAVE_ARCH_nn_add1
#define HAVE_ARCH_nn_sub1
#define HAVE_ARCH_nn_neg_c

and nn_linear.c in the top level directory has the include:

#include "nn_linear_arch.h"

which picks up the compiler exclusions from arch/nn_linear_x64.h.

On Windows x64, for example, this is achieved by copying 
arch/nn_linear_x64.h to nn_linear_arch.h in the top level directory 
before the build, to force the necessary exclusions.

On *nix, when builing with inline assembly code, the file nn_linear_arch.h 
is automatically generated by configure by #include'ing the relevant .h
files from arch/include, in which the necessary guards (and inline assembly)
are defined.

3. Architeture Specific Assembler Code
======================================

If standalone assembler code versions of routines are available for
any architecture, they reside within the asm sub-directory in the 
arch directory.  The file naming convention used in arch/asm is:

  <bsdnt_function_category>_<platform>_<cpu>.(asm|h)

Where <platform> is as described earlier and the 'asm' file
name extension might be different for some systems. The <cpu> item
designates the processor for which the assembler in question is
intended.

For example, x64 assembler code for core2 processors would use:

  nn_linear_x64_core2.asm  -- x64 assembler code for core2 cpus
  nn_linear_x64_core2.h    -- defines to exclude functions provided 

If an assembler version is available it has to override any version in
the BSDNT root directory AND any architecture specific version that is
provided in arch.

To achieve this (using the x64 assembler code for the linear functions
on core2 systems as an example), the file:

   arch/asm/nn_linear_x64_core2.h

holding exclusion defines for any assembler code functions is first 
copied into:

   arch/nn_linear_x64_asm.h

where it will be picked up by the file nn_linear_x64.c using an include:

#include "nn_linear_x64_asm.h"

The defines in this file will prevent the compilation of any architecture 
specific versions for which assembler code is available.

Any assembler code must also cause exclusions in nn_linear.c in root. This
is achieved by appending the file 'nn_linear_x64_asm.h' (now in arch
as a result of the earlier copying operation) to 'nn_linear_x64.h' and
copying the result to 'nn_linear_arch.h' in root.

So to build for x64 using the core2 assembler code, the two pre-build
copying steps are:

  copy  arch/asm/nn_linear_x64_core2.h  arch/nn_linear_x64_asm.h
  copy  arch/nn_linear_x64.h + arch/nn_linear_x64_asm.h  nn_linear_arch.h

The build system then has to arrange to build:
  
  nn_linear.c
  arch/nn_linear_x64.c
  arch/x64/nn_linear_x64_core2.asm

The same hierarchy applies to nn_quadratic.c and to any other root level
code for which architecture specific or assembler code alternatives are
available.

4. Inline Assembly
==================

On *nix, the arch/inline directory holds files of the form:

   <bsdnt_function_category>_<platform>.h
   <bsdnt_function_category>_<platform>_<cpu>.h

These contain the necessary guards and inline assembly for the specified 
platform, or platform and cpu, respectively.

Both the platform and cpu are automatically detected by configure and
the arch/inline directory is searched for files that match that data. 

Configure then automatically generates the files:

   <bsdnt_function_category>_arch.h

at the top level directory, filling it with defines of the form:

#include "arch/inline/<bsdnt_function_category>_<platform>_<cpu>.h"
#include "arch/inline/<bsdnt_function_category>_<platform>.h"

As this is all automatic, all the developer need do to add inline
assembly is to put the relevant .h file, correctly named for the
intended platform and/or cpu, in the arch/inline directory, and make
sure it contains the necessary override defines for the functions
provided, as discussed at the beginning of this document. No build
system modifications are necessary.

For example, to override nn_add_mc in nn_linear.c on x86_64 on a 
core2 cpu, simply place the file containing the relevant inline
assembly into arch/inline/nn_linear_x86_64_core2.h and ensure it
contains the line:

   #define HAVE_ARCH_nn_add_mc

When configure is run again, this file will be automatically included
in the build, overriding the generic C version of the function nn_add_mc
as defined in nn_linear.c.

At this point the platforms that are recognised are:

   x86     x86 architecture with 32 bit OS kernel
   x86_64  x86 architecture with 64 bit OS kernel

The cpu's recognised to date are:

   k10      AMD K10 (Phenom, Phenom II, etc)
   k8       AMD K8
   atom     Intel Atom
   core2    Intel Core 2 Duo
   nehalem  Intel i3/5/7 nehalem core
   p4       Intel Pentium 4

It is possible to use inline assembly code written for more than one 
processor in a single build. For example, it is possible to use k8 and k10
code with the latter overriding the former where there are separate 
versions of the same function. This is done by changing the list of EXTS as 
recorded in the configure file. 

For example, configure contains the lines:

        k10)
            EXTS="_k10 _k8";;

This means that when the build machine is an AMD K10, inline assembly code
written for the k10 is selected first and overrides everything else. But if
there is k8 code for functions not yet overridden, it will also be used.
Finally any code in the generic file:

   arch/inline/<bsdnt_function_category>_x86_64.h

may provide routines that are generic to all x86_64 machines. Anything that
remains to be defined is picked up from the primary/generic C file, 
<bsdnt_function_category>.c in the top level directory.

Again, configure manages the build of the relevant files automatically. All
that is required is to provide the correctly named files and ensure they 
contain the relevant override defines for functions they provide.

The developer is not required to provide any specific file. If configure 
doesn't find an architecture specific file for a given plaform or cpu it does 
not raise an error. Thus only files which actually contain code need exist for
a given architecture.
